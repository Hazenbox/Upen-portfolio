{"history":[{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"gradient","usesPingPong":false,"speed":0.25,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform vec2 uMousePos;vec3 getColor(int index) {\nswitch(index) {\ncase 0: return vec3(0, 0.5058823529411764, 0.9686274509803922);\ncase 1: return vec3(0, 0.2784313725490196, 0.5490196078431373);\ncase 2: return vec3(0, 0.42745098039215684, 0.8274509803921568);\ncase 3: return vec3(0.27058823529411763, 0.6039215686274509, 1);\ncase 4: return vec3(0.611764705882353, 0.7803921568627451, 1);\ncase 5: return vec3(0.9098039215686274, 0.9490196078431372, 1);\ncase 6: return vec3(0, 0, 0);\ncase 7: return vec3(0, 0, 0);\ncase 8: return vec3(0, 0, 0);\ncase 9: return vec3(0, 0, 0);\ncase 10: return vec3(0, 0, 0);\ncase 11: return vec3(0, 0, 0);\ncase 12: return vec3(0, 0, 0);\ncase 13: return vec3(0, 0, 0);\ncase 14: return vec3(0, 0, 0);\ncase 15: return vec3(0, 0, 0);\ndefault: return vec3(0.0);\n}\n}const float PI = 3.14159265;vec2 rotate(vec2 coord, float angle) {\nfloat s = sin(angle);\nfloat c = cos(angle);\nreturn vec2(\ncoord.x * c - coord.y * s,\ncoord.x * s + coord.y * c\n);\n}out vec4 fragColor;vec3 getColor(vec2 uv) {return vec3(0, 0.5058823529411764, 0.9686274509803922);\n}void main() {vec2 uv = vTextureCoord;\nvec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nuv -= pos;\nuv /= (0.5000*2.);\nuv = rotate(uv, (0.0000 - 0.5) * 2. * PI);\nvec4 color = vec4(getColor(uv), 0.4900);\nfragColor = color;\n}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = aTextureCoord;\n}"],"data":{"downSample":0.5,"depth":false,"uniforms":{},"isBackground":true},"id":"effect"},{"breakpoints":[],"visible":true,"locked":false,"aspectRatio":1.0793650793650795,"layerName":"","userDownsample":1,"isElement":true,"opacity":1,"effects":[],"displace":0,"trackMouse":0,"anchorPoint":"center","mouseMomentum":0,"blendMode":"NORMAL","bgDisplace":0,"mask":0,"maskBackground":{"type":"Vec3","_x":0,"_y":0,"_z":0},"maskAlpha":0,"maskDepth":0,"dispersion":0,"axisTilt":0,"states":{"appear":[],"scroll":[],"hover":[]},"translateX":403,"translateY":167,"layerType":"shape","width":0.49660178547135064,"widthMode":"relative","height":0.4600869483043395,"heightMode":"auto","left":0.3550175441459218,"leftMode":"relative","top":0.6396576569756648,"topMode":"relative","rotation":0,"trackAxes":"xy","borderRadius":0,"gradientAngle":0,"strokeWidth":0,"coords":[[0,0],[0.49660178547135064,0],[0.49660178547135064,0.4600869483043395],[0,0.4600869483043395]],"fill":["#006DD3"],"fitToCanvas":false,"gradientType":"linear","type":"circle","stroke":["#000000"],"numSides":3,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nin vec2 vTextureCoord;\nin vec3 vVertexPosition;uniform vec2 uMousePos;\nuniform sampler2D uBgTexture;\nuniform sampler2D uTexture;\nuniform int uSampleBg;const float STEPS = 24.0;\nconst float PI = 3.1415926;out vec4 fragColor;vec4 getNormalOutput(vec4 color, vec4 background) {\ncolor = mix(background, color + background * (1.0 - color.a), 1.0000);\nreturn color;\n}vec4 getOutputByMode(vec4 color, vec4 background) {\nreturn getNormalOutput(color, background);\n}void main() {\nvec2 uv = vTextureCoord;\nvec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.0000);uv -= pos;vec4 background = vec4(0);\nif(uSampleBg == 1) {\nbackground = texture(uBgTexture, vTextureCoord);\n}\nvec4 color = texture(uTexture, uv);vec4 col = getOutputByMode(color, background);fragColor = col;\n}"],"compiledVertexShaders":["#version 300 es\nprecision highp float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;\nuniform vec2 uMousePos;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\nfloat angleX = uMousePos.y * 0.5 - 0.25;\nfloat angleY = (1.-uMousePos.x) * 0.5 - 0.25;mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0,\n0.0, cos(angleX), -sin(angleX), 0.0,\n0.0, sin(angleX), cos(angleX), 0.0,\n0.0, 0.0, 0.0, 1.0);\nmat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0,\n0.0, 1.0, 0.0, 0.0,\n-sin(angleY), 0.0, cos(angleY), 0.0,\n0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY;\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz;\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"uniforms":{}},"id":"shape"},{"breakpoints":[],"visible":true,"locked":false,"aspectRatio":1.0158730158730158,"layerName":"","userDownsample":1,"isElement":true,"opacity":1,"effects":[],"displace":0,"trackMouse":0,"anchorPoint":"center","mouseMomentum":0,"blendMode":"MULTIPLY","bgDisplace":0,"mask":0,"maskBackground":{"type":"Vec3","_x":0,"_y":0,"_z":0},"maskAlpha":0,"maskDepth":0,"dispersion":0,"axisTilt":0,"states":{"appear":[],"scroll":[],"hover":[]},"translateX":609,"translateY":132,"layerType":"shape","width":0.46738991573774175,"widthMode":"relative","height":0.46008694830433955,"heightMode":"auto","left":0.7457263018329404,"leftMode":"relative","top":0.5757566919333954,"topMode":"relative","rotation":0,"trackAxes":"xy","borderRadius":0,"gradientAngle":0,"strokeWidth":0,"coords":[[0,0],[0.46738991573774175,0],[0.46738991573774175,0.46008694830433955],[0,0.46008694830433955]],"fill":["#005AAF"],"fitToCanvas":false,"gradientType":"linear","type":"circle","stroke":["#000000"],"numSides":3,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nin vec2 vTextureCoord;\nin vec3 vVertexPosition;uniform vec2 uMousePos;\nuniform sampler2D uBgTexture;\nuniform sampler2D uTexture;\nuniform int uSampleBg;vec3 blend (int blendMode, vec3 src, vec3 dst) {\nreturn src * dst;\n}const float STEPS = 24.0;\nconst float PI = 3.1415926;out vec4 fragColor;vec4 getNormalOutput(vec4 color, vec4 background) {\nvec3 unpremultColor = color.rgb / max(color.a, 0.0001);\nvec3 blendedColor = blend(3, unpremultColor, background.rgb);\ncolor = vec4(blendedColor, 1.0) * (color.a * 1.0000);\ncolor = color + background * (1.0 - color.a);\nreturn color;\n}vec4 getOutputByMode(vec4 color, vec4 background) {\nreturn getNormalOutput(color, background);\n}void main() {\nvec2 uv = vTextureCoord;\nvec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.0000);uv -= pos;vec4 background = vec4(0);\nif(uSampleBg == 1) {\nbackground = texture(uBgTexture, vTextureCoord);\n}\nvec4 color = texture(uTexture, uv);vec4 col = getOutputByMode(color, background);fragColor = col;\n}"],"compiledVertexShaders":["#version 300 es\nprecision highp float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;\nuniform vec2 uMousePos;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\nfloat angleX = uMousePos.y * 0.5 - 0.25;\nfloat angleY = (1.-uMousePos.x) * 0.5 - 0.25;mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0,\n0.0, cos(angleX), -sin(angleX), 0.0,\n0.0, sin(angleX), cos(angleX), 0.0,\n0.0, 0.0, 0.0, 1.0);\nmat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0,\n0.0, 1.0, 0.0, 0.0,\n-sin(angleY), 0.0, cos(angleY), 0.0,\n0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY;\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz;\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"uniforms":{}},"id":"shape1"},{"breakpoints":[],"visible":true,"locked":false,"aspectRatio":0.996031746031746,"layerName":"","userDownsample":1,"isElement":true,"opacity":1,"effects":[],"displace":0,"trackMouse":0,"anchorPoint":"center","mouseMomentum":0,"blendMode":"NORMAL","bgDisplace":0,"mask":0,"maskBackground":{"type":"Vec3","_x":0,"_y":0,"_z":0},"maskAlpha":0,"maskDepth":0,"dispersion":0,"axisTilt":0,"states":{"appear":[],"scroll":[],"hover":[]},"translateX":471,"translateY":29,"layerType":"shape","width":0.45826120644598894,"widthMode":"relative","height":0.4600869483043395,"heightMode":"auto","left":0.4983382800264403,"leftMode":"relative","top":0.38770528052328834,"topMode":"relative","rotation":0,"trackAxes":"xy","borderRadius":0,"gradientAngle":0,"strokeWidth":0,"coords":[[0,0],[0.45826120644598894,0],[0.45826120644598894,0.4600869483043395],[0,0.4600869483043395]],"fill":["#74a4ff"],"fitToCanvas":false,"gradientType":"linear","type":"circle","stroke":["#000000"],"numSides":3,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nin vec2 vTextureCoord;\nin vec3 vVertexPosition;uniform vec2 uMousePos;\nuniform sampler2D uBgTexture;\nuniform sampler2D uTexture;\nuniform int uSampleBg;const float STEPS = 24.0;\nconst float PI = 3.1415926;out vec4 fragColor;vec4 getNormalOutput(vec4 color, vec4 background) {\ncolor = mix(background, color + background * (1.0 - color.a), 1.0000);\nreturn color;\n}vec4 getOutputByMode(vec4 color, vec4 background) {\nreturn getNormalOutput(color, background);\n}void main() {\nvec2 uv = vTextureCoord;\nvec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.0000);uv -= pos;vec4 background = vec4(0);\nif(uSampleBg == 1) {\nbackground = texture(uBgTexture, vTextureCoord);\n}\nvec4 color = texture(uTexture, uv);vec4 col = getOutputByMode(color, background);fragColor = col;\n}"],"compiledVertexShaders":["#version 300 es\nprecision highp float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;\nuniform vec2 uMousePos;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\nfloat angleX = uMousePos.y * 0.5 - 0.25;\nfloat angleY = (1.-uMousePos.x) * 0.5 - 0.25;mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0,\n0.0, cos(angleX), -sin(angleX), 0.0,\n0.0, sin(angleX), cos(angleX), 0.0,\n0.0, 0.0, 0.0, 1.0);\nmat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0,\n0.0, 1.0, 0.0, 0.0,\n-sin(angleY), 0.0, cos(angleY), 0.0,\n0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY;\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz;\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"uniforms":{}},"id":"shape2"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"blur","usesPingPong":false,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;\nfloat ease (int easingFunc, float t) {\nreturn t;\n}out vec4 fragColor;const int kernelSize = 36;\nfloat getGaussianWeight(int index) {\nswitch(index) {\ncase 0: return 0.00094768;\ncase 1: return 0.00151965;\ncase 2: return 0.00237008;\ncase 3: return 0.00359517;\ncase 4: return 0.0053041;\ncase 5: return 0.00761097;\ncase 6: return 0.01062197;\ncase 7: return 0.01441804;\ncase 8: return 0.01903459;\ncase 9: return 0.0244409;\ncase 10: return 0.03052299;\ncase 11: return 0.03707432;\ncase 12: return 0.04379813;\ncase 13: return 0.05032389;\ncase 14: return 0.05623791;\ncase 15: return 0.06112521;\ncase 16: return 0.06461716;\ncase 17: return 0.06643724;\ncase 18: return 0.06643724;\ncase 19: return 0.06461716;\ncase 20: return 0.06112521;\ncase 21: return 0.05623791;\ncase 22: return 0.05032389;\ncase 23: return 0.04379813;\ncase 24: return 0.03707432;\ncase 25: return 0.03052299;\ncase 26: return 0.0244409;\ncase 27: return 0.01903459;\ncase 28: return 0.01441804;\ncase 29: return 0.01062197;\ncase 30: return 0.00761097;\ncase 31: return 0.0053041;\ncase 32: return 0.00359517;\ncase 33: return 0.00237008;\ncase 34: return 0.00151965;\ncase 35: return 0.00094768;\ndefault: return 0.0;\n}\n}vec4 GaussianBlur(sampler2D tex, vec2 uv, vec2 direction) {\nvec4 color = vec4(0.0);\nvec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nfloat inner = distance(uv, pos);\nfloat outer = max(0., 1.-distance(uv, pos));float amt = 0 <= 1 ? 6. : 11.;\nfloat amount = (2.9740 * amt) * ease(0, mix(inner, outer, 0.5000));\ncolor += texture(tex, uv) * getGaussianWeight(0);\nfor (int i = 0; i < kernelSize; i++) {\nfloat x = float(i - kernelSize / 2) * amount;\ncolor += texture(tex, uv + vec2(x * 0.001) * direction * vec2(0.5000, 1. - 0.5000)) * getGaussianWeight(i);\n}\nreturn color;\n}vec4 blur(vec2 uv, vec2 direction) {\nreturn GaussianBlur(uTexture, uv, direction);\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = vec4(0);\nint dir = 0 % 2;\nvec2 direction = dir == 1 ? vec2(0, uResolution.x/uResolution.y) : vec2(1, 0);color = blur(uv, direction);\nfragColor = color;}","#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;\nfloat ease (int easingFunc, float t) {\nreturn t;\n}out vec4 fragColor;const int kernelSize = 36;\nfloat getGaussianWeight(int index) {\nswitch(index) {\ncase 0: return 0.00094768;\ncase 1: return 0.00151965;\ncase 2: return 0.00237008;\ncase 3: return 0.00359517;\ncase 4: return 0.0053041;\ncase 5: return 0.00761097;\ncase 6: return 0.01062197;\ncase 7: return 0.01441804;\ncase 8: return 0.01903459;\ncase 9: return 0.0244409;\ncase 10: return 0.03052299;\ncase 11: return 0.03707432;\ncase 12: return 0.04379813;\ncase 13: return 0.05032389;\ncase 14: return 0.05623791;\ncase 15: return 0.06112521;\ncase 16: return 0.06461716;\ncase 17: return 0.06643724;\ncase 18: return 0.06643724;\ncase 19: return 0.06461716;\ncase 20: return 0.06112521;\ncase 21: return 0.05623791;\ncase 22: return 0.05032389;\ncase 23: return 0.04379813;\ncase 24: return 0.03707432;\ncase 25: return 0.03052299;\ncase 26: return 0.0244409;\ncase 27: return 0.01903459;\ncase 28: return 0.01441804;\ncase 29: return 0.01062197;\ncase 30: return 0.00761097;\ncase 31: return 0.0053041;\ncase 32: return 0.00359517;\ncase 33: return 0.00237008;\ncase 34: return 0.00151965;\ncase 35: return 0.00094768;\ndefault: return 0.0;\n}\n}vec4 GaussianBlur(sampler2D tex, vec2 uv, vec2 direction) {\nvec4 color = vec4(0.0);\nvec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nfloat inner = distance(uv, pos);\nfloat outer = max(0., 1.-distance(uv, pos));float amt = 1 <= 1 ? 6. : 11.;\nfloat amount = (2.9740 * amt) * ease(0, mix(inner, outer, 0.5000));\ncolor += texture(tex, uv) * getGaussianWeight(0);\nfor (int i = 0; i < kernelSize; i++) {\nfloat x = float(i - kernelSize / 2) * amount;\ncolor += texture(tex, uv + vec2(x * 0.001) * direction * vec2(0.5000, 1. - 0.5000)) * getGaussianWeight(i);\n}\nreturn color;\n}vec4 blur(vec2 uv, vec2 direction) {\nreturn GaussianBlur(uTexture, uv, direction);\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = vec4(0);\nint dir = 1 % 2;\nvec2 direction = dir == 1 ? vec2(0, uResolution.x/uResolution.y) : vec2(1, 0);color = blur(uv, direction);\nfragColor = color;}","#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;\nfloat ease (int easingFunc, float t) {\nreturn t;\n}out vec4 fragColor;const int kernelSize = 36;\nfloat getGaussianWeight(int index) {\nswitch(index) {\ncase 0: return 0.00094768;\ncase 1: return 0.00151965;\ncase 2: return 0.00237008;\ncase 3: return 0.00359517;\ncase 4: return 0.0053041;\ncase 5: return 0.00761097;\ncase 6: return 0.01062197;\ncase 7: return 0.01441804;\ncase 8: return 0.01903459;\ncase 9: return 0.0244409;\ncase 10: return 0.03052299;\ncase 11: return 0.03707432;\ncase 12: return 0.04379813;\ncase 13: return 0.05032389;\ncase 14: return 0.05623791;\ncase 15: return 0.06112521;\ncase 16: return 0.06461716;\ncase 17: return 0.06643724;\ncase 18: return 0.06643724;\ncase 19: return 0.06461716;\ncase 20: return 0.06112521;\ncase 21: return 0.05623791;\ncase 22: return 0.05032389;\ncase 23: return 0.04379813;\ncase 24: return 0.03707432;\ncase 25: return 0.03052299;\ncase 26: return 0.0244409;\ncase 27: return 0.01903459;\ncase 28: return 0.01441804;\ncase 29: return 0.01062197;\ncase 30: return 0.00761097;\ncase 31: return 0.0053041;\ncase 32: return 0.00359517;\ncase 33: return 0.00237008;\ncase 34: return 0.00151965;\ncase 35: return 0.00094768;\ndefault: return 0.0;\n}\n}vec4 GaussianBlur(sampler2D tex, vec2 uv, vec2 direction) {\nvec4 color = vec4(0.0);\nvec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nfloat inner = distance(uv, pos);\nfloat outer = max(0., 1.-distance(uv, pos));float amt = 2 <= 1 ? 6. : 11.;\nfloat amount = (2.9740 * amt) * ease(0, mix(inner, outer, 0.5000));\ncolor += texture(tex, uv) * getGaussianWeight(0);\nfor (int i = 0; i < kernelSize; i++) {\nfloat x = float(i - kernelSize / 2) * amount;\ncolor += texture(tex, uv + vec2(x * 0.001) * direction * vec2(0.5000, 1. - 0.5000)) * getGaussianWeight(i);\n}\nreturn color;\n}vec4 blur(vec2 uv, vec2 direction) {\nreturn GaussianBlur(uTexture, uv, direction);\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = vec4(0);\nint dir = 2 % 2;\nvec2 direction = dir == 1 ? vec2(0, uResolution.x/uResolution.y) : vec2(1, 0);color = blur(uv, direction);\nfragColor = color;}","#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;\nfloat ease (int easingFunc, float t) {\nreturn t;\n}\nuvec2 pcg2d(uvec2 v) {\nv = v * 1664525u + 1013904223u;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nv ^= v >> 16;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nreturn v;\n}float randFibo(vec2 p) {\nuvec2 v = floatBitsToUint(p);\nv = pcg2d(v);\nuint r = v.x ^ v.y;\nreturn float(r) / float(0xffffffffu);\n}out vec4 fragColor;const int kernelSize = 36;\nfloat getGaussianWeight(int index) {\nswitch(index) {\ncase 0: return 0.00094768;\ncase 1: return 0.00151965;\ncase 2: return 0.00237008;\ncase 3: return 0.00359517;\ncase 4: return 0.0053041;\ncase 5: return 0.00761097;\ncase 6: return 0.01062197;\ncase 7: return 0.01441804;\ncase 8: return 0.01903459;\ncase 9: return 0.0244409;\ncase 10: return 0.03052299;\ncase 11: return 0.03707432;\ncase 12: return 0.04379813;\ncase 13: return 0.05032389;\ncase 14: return 0.05623791;\ncase 15: return 0.06112521;\ncase 16: return 0.06461716;\ncase 17: return 0.06643724;\ncase 18: return 0.06643724;\ncase 19: return 0.06461716;\ncase 20: return 0.06112521;\ncase 21: return 0.05623791;\ncase 22: return 0.05032389;\ncase 23: return 0.04379813;\ncase 24: return 0.03707432;\ncase 25: return 0.03052299;\ncase 26: return 0.0244409;\ncase 27: return 0.01903459;\ncase 28: return 0.01441804;\ncase 29: return 0.01062197;\ncase 30: return 0.00761097;\ncase 31: return 0.0053041;\ncase 32: return 0.00359517;\ncase 33: return 0.00237008;\ncase 34: return 0.00151965;\ncase 35: return 0.00094768;\ndefault: return 0.0;\n}\n}vec4 GaussianBlur(sampler2D tex, vec2 uv, vec2 direction) {\nvec4 color = vec4(0.0);\nvec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nfloat inner = distance(uv, pos);\nfloat outer = max(0., 1.-distance(uv, pos));float amt = 3 <= 1 ? 6. : 11.;\nfloat amount = (2.9740 * amt) * ease(0, mix(inner, outer, 0.5000));\ncolor += texture(tex, uv) * getGaussianWeight(0);\nfor (int i = 0; i < kernelSize; i++) {\nfloat x = float(i - kernelSize / 2) * amount;\ncolor += texture(tex, uv + vec2(x * 0.001) * direction * vec2(0.5000, 1. - 0.5000)) * getGaussianWeight(i);\n}\nreturn color;\n}vec4 blur(vec2 uv, vec2 direction) {\nreturn GaussianBlur(uTexture, uv, direction);\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = vec4(0);\nint dir = 3 % 2;\nvec2 direction = dir == 1 ? vec2(0, uResolution.x/uResolution.y) : vec2(1, 0);color = blur(uv, direction);float dither = (randFibo(gl_FragCoord.xy) - 0.5) / 255.0;\ncolor.rgb += dither;\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"downSample":0.25,"depth":false,"uniforms":{},"isBackground":false,"passes":[{"prop":"vertical","value":1,"downSample":0.25},{"prop":"vertical","value":2,"downSample":0.5},{"prop":"vertical","value":3,"downSample":0.5}]},"id":"effect1"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"sdf_shape","usesPingPong":false,"texture":false,"speed":0.51,"trackMouseMove":0,"trackAxes":"xy","mouseMomentum":1,"trackMouse":0.15,"animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nprecision highp int;in vec2 vTextureCoord;\nuniform sampler2D uTexture;uniform float uTime;uniform vec2 uMousePos;\nuniform vec2 uResolution;uvec2 pcg2d(uvec2 v) {\nv = v * 1664525u + 1013904223u;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nv ^= v >> 16;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nreturn v;\n}float randFibo(vec2 p) {\nuvec2 v = floatBitsToUint(p);\nv = pcg2d(v);\nuint r = v.x ^ v.y;\nreturn float(r) / float(0xffffffffu);\n}const float PI = 3.141592653;\nconst float PI2 = 6.283185306;\nconst int DISP_STEPS = 12;\nconst vec3 viewDir = vec3(0,0, -4.25);ivec2 customTexSize;\nfloat customTexAspect;const mat3 ROT_Y_90 = mat3(\n0.0, 0.0, 1.0,\n0.0, 1.0, 0.0,\n-1.0, 0.0, 0.0\n);const mat3 ROT_Z_90 = mat3(\n0.0, -1.0, 0.0,\n1.0, 0.0, 0.0,\n0.0, 0.0, 1.0\n);const mat3 ROT_X_90 = mat3(\n1.0, 0.0, 0.0,\n0.0, 0.0, -1.0,\n0.0, 1.0, 0.0\n);mat3 rotY(float ang) {\nfloat c = cos(ang), s = sin(ang);\nreturn mat3(c, 0.0, s, 0.0, 1.0, 0.0, -s, 0.0, c);\n}mat3 rotX(float ang) {\nfloat c = cos(ang), s = sin(ang);\nreturn mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c);\n}mat3 rotZ(float ang) {\nfloat c = cos(ang), s = sin(ang);\nreturn mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);\n}vec3 twistY(vec3 p, float amount) {\nfloat c = cos(amount * p.y);\nfloat s = sin(amount * p.y);\nmat2 m = mat2(c, -s, s, c);\nreturn vec3(m * p.xz, p.y);\n}vec3 twistX(vec3 p, float amount) {\nfloat c = cos(amount * p.x);\nfloat s = sin(amount * p.x);\nmat2 m = mat2(c, -s, s, c);\nreturn vec3(p.x, m * p.yz);\n}float opExtrusion(vec3 p, float d, float h) {\nvec2 w = vec2( d, abs(p.z) - h );\nreturn min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}float sdStar5(vec2 p, float r, float rf)\n{\nconst vec2 k1 = vec2(0.809016994375, -0.587785252292);\nconst vec2 k2 = vec2(-k1.x,k1.y);\np.x = abs(p.x);\np -= 2.0*max(dot(k1,p),0.0)*k1;\np -= 2.0*max(dot(k2,p),0.0)*k2;\np.x = abs(p.x);\np.y -= r;\nvec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\nfloat h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\nreturn length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}float sdRoundedBox( vec2 p, vec2 b, vec4 r ) {\nr.xy = (p.x>0.0)?r.xy : r.zw;\nr.x = (p.y>0.0)?r.x : r.y;\nvec2 q = abs(p)-b+r.x;\nreturn min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}float squircle(vec3 p) {\np *= ROT_Y_90;\np *= ROT_X_90;\nfloat d = sdRoundedBox(p.xy, vec2(0.75 + 0.0500, 0.75 + (1. - 0.0500)), vec4(0.33));\nreturn opExtrusion(p, d, 0.4200);\n}vec3 getRepeat(vec3 p) {\nfloat spacing = (0.5000 + 0.4600 * 0.38) * 8.;\nreturn p;\n}vec3 getThreeDRepeat(vec3 p) {\nfloat spacing = (0.5000 + 0.4600 * 0.38) * 8.;\nreturn p;\n}vec3 getAdjustedP(vec3 p) {\nfloat scale = max(0.5600, 0.000000001);\nfloat scaleFactor = 1.0/scale;\nvec3 adjustedP = p * scaleFactor;vec2 twist = vec2(0.7, 0.82);adjustedP.xy *= vec2(uResolution.x / uResolution.y, 1);adjustedP *= (1. + (0.4600 + 0.01));vec2 mousePos = mix(vec2(0), uMousePos - 0.5, 0.1500);\nvec2 axis = vec2(-1. * vec3(0.48503740648379057, 0.5187032418952618, 0.7317).y - 1. + mousePos.y/PI, vec3(0.48503740648379057, 0.5187032418952618, 0.7317).x + mousePos.x/PI) * 2.;adjustedP = getRepeat(adjustedP);float baseTime = uTime * 0.02;\nfloat timeX = vec3(0, 0.5, 0).x * baseTime;\nfloat timeY = vec3(0, 0.5, 0).y * baseTime;\nfloat timeZ = vec3(0, 0.5, 0).z * baseTime;mat3 rotYMat = rotY(axis.y * PI);\nmat3 rotXMat = rotX(axis.x * PI);\nmat3 rotZMat = rotZ(vec3(0.48503740648379057, 0.5187032418952618, 0.7317).z * 2.0 * PI);mat3 combinedRotation = rotZMat * rotYMat * rotXMat;\nmat3 combinedAnimation = rotZ(timeZ) * rotX(timeX) * rotY(timeY);adjustedP = combinedRotation * adjustedP;\nadjustedP = combinedAnimation * adjustedP;\nadjustedP = getThreeDRepeat(adjustedP);\nadjustedP = mix(adjustedP, twistY(adjustedP, -1.0 * twist.y), step(0.0, abs(twist.y)));\nadjustedP = mix(adjustedP, twistX(adjustedP, -1.0 * twist.x), step(0.0, abs(twist.x)));return adjustedP;\n}float getMergedSDF(vec3 p) {\np = getAdjustedP(p);\nreturn squircle(p);\n}vec3 noFrostOrDispersion(vec3 rd, vec3 normal) {\nfloat ior = 1.0 / (1.0 + 0.7000 * 0.25);\nvec3 refractedRay = refract(rd, normal, ior);\nreturn texture(uTexture, vTextureCoord - refractedRay.xy).rgb;\n}vec3 frostOrDispersion(vec3 rd, vec3 normal) {\nvec3 refractionColor = vec3(0);\nfloat iorBase = 1. + 0.7000 * 0.25;vec3 dispCoefficients = vec3(0.03, 0.06, 0.1) * 0.2500 * 1.2;for (int i = 0; i < DISP_STEPS; ++i) {\nfloat step = float(i) / float(DISP_STEPS);\nvec3 disp = step * dispCoefficients;\nvec3 ior = 1.0 / (iorBase + disp);vec3 refractedRayR = refract(rd, normal, ior.r);\nvec3 refractedRayG = refract(rd, normal, ior.g);\nvec3 refractedRayB = refract(rd, normal, ior.b);refractionColor.r += texture(uTexture, vTextureCoord - refractedRayR.xy).r;\nrefractionColor.g += texture(uTexture, vTextureCoord - refractedRayG.xy).g;\nrefractionColor.b += texture(uTexture, vTextureCoord - refractedRayB.xy).b;\n}return clamp(refractionColor / float(DISP_STEPS), 0.0, 1.0);\n}vec3 calculateNormal(vec3 p, float eps) {\nvec2 e = vec2(1.0, -1.0) * eps * 0.5;\nreturn normalize(\ne.xyy * getMergedSDF(p + e.xyy) +\ne.yyx * getMergedSDF(p + e.yyx) +\ne.yxy * getMergedSDF(p + e.yxy) +\ne.xxx * getMergedSDF(p + e.xxx)\n);\n}vec3 sampleTexture(vec3 rd, vec3 normal) {return frostOrDispersion(rd, normal);\nreturn noFrostOrDispersion(rd, normal);\n}float scene(vec3 p) {\nreturn max(0.0000000001, getMergedSDF(p) - (0.4600 + 0.005)) * max(0.5600, 0.000000001);\n}const int STEPS = 128;\nconst float MAX_DISTANCE = 100.0;vec4 rayMarch(vec3 ro, vec3 rd) {\nfloat pixelSize = 0.0025;\nfloat traveled = 0.;\nvec3 entryPoint = vec3(0.0);\nvec3 entryNormal = vec3(0.0);\nfloat partialAlpha = 0.0;\nfloat lastDistance = 0.0;\nfloat smoothing = mix(1., 4., 0.7300);for (int i = 0; i < STEPS; ++i) {\nvec3 currentPos = ro + rd * traveled;\nfloat distance = scene(currentPos);\nfloat progress = float(i)/float(STEPS);\nfloat step = distance * mix(1., 1.5, progress);if (distance > MAX_DISTANCE) break;if (distance < pixelSize) {\npartialAlpha = 1.;\nentryPoint = currentPos;\nentryNormal = calculateNormal(entryPoint, pixelSize * smoothing);\nbreak;\n}lastDistance = distance;traveled += max(step, pixelSize);\nif (traveled > MAX_DISTANCE) break;\n}if (partialAlpha == 0.0) {\nreturn texture(uTexture, vTextureCoord);\n}vec3 samplePosition = mix(rd, entryPoint, 0.0000);vec3 refractionColor = texture(uTexture, vTextureCoord).rgb;refractionColor = sampleTexture(samplePosition, entryNormal);\nvec3 lightDir = vec3(((vec2(vec3(0.25, 0.25, -3).x, 1.-vec3(0.25, 0.25, -3).y) - 0.333) * 3.) - vec2(0.5, 0.5), vec3(0.25, 0.25, -3).z);\nvec3 normLightDir = normalize(lightDir);float lightAndShadow = dot(entryNormal, normLightDir);\nvec3 lightColor = mix(vec3(1), vec3(0, 0.35294117647058826, 0.6862745098039216), 1. - 0.0000);\nvec3 fresnelEffect = vec3(0.0);vec3 specularEffect = vec3(0.0);vec3 combinedEffects = fresnelEffect + specularEffect;\nvec3 finalColor = mix(refractionColor, vec3(0, 0.35294117647058826, 0.6862745098039216) * lightAndShadow, 0.0000);\nfinalColor += combinedEffects;vec4 outputColor = vec4(finalColor, 1.);return outputColor;\n}out vec4 fragColor;void main() {\nvec4 col = vec4(0);\nvec4 bg = texture(uTexture, vTextureCoord);if(0.5600 <= 0.0001 || 1.0000 <= 0.0001) {\ncol = vec4(0);\nif(1 == 1) {\ncol = bg;\n}\nfragColor = col;\nreturn;\n}vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nvec2 uv = vTextureCoord - pos;\nfloat fovFactor = tan(radians(20.) * 0.5);\nvec3 rd = vec3(uv * fovFactor, 0.5);\ncol = rayMarch(viewDir, rd);\nfloat dither = (randFibo(vTextureCoord.xy) - 0.5) / 255.0;\ncol += dither;col = mix(bg, col, 1.0000);\nfragColor = col;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect2"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"vignette","usesPingPong":false,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nin vec3 vVertexPosition;\nin vec2 vTextureCoord;\nuniform sampler2D uTexture;\nuniform vec2 uResolution;out vec4 fragColor;\nmat2 rot(float a) {\nreturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}\nvoid main() {\nvec2 uv = vTextureCoord;\nvec4 bg = texture(uTexture, uv);\nfloat luma = dot(bg.rgb, vec3(0.299, 0.587, 0.114));\nfloat displacement = (luma - 0.5) * 0.0000 * 0.5;\nvec2 aspectRatio = vec2(uResolution.x/uResolution.y, 1.0);\nvec2 skew = vec2(0.5000, 1.0 - 0.5000);\nfloat halfRadius = 0.2200 * 0.5;\nfloat innerEdge = halfRadius - 1.0000 * halfRadius * 0.5;\nfloat outerEdge = halfRadius + 1.0000 * halfRadius * 0.5;\nvec2 pos = vec2(0.5, 0.5);\nconst float TWO_PI = 6.28318530718;\nvec2 scaledUV = uv * aspectRatio * rot(0.0000 * TWO_PI) * skew;\nvec2 scaledPos = pos * aspectRatio * rot(0.0000 * TWO_PI) * skew;\nfloat radius = distance(scaledUV, scaledPos);\nfloat falloff = smoothstep(innerEdge + displacement, outerEdge + displacement, radius);\nvec3 finalColor;finalColor = mix(bg.rgb, mix(bg.rgb, vec3(1, 1, 1), 1.0000), falloff);float alpha = max(bg.a, falloff * 1.0000);\nvec4 color = mix(bg * (1.-falloff), vec4(finalColor * alpha, alpha), 1.0000);\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect3"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"sphere","usesPingPong":false,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nin vec3 vVertexPosition;\nin vec2 vTextureCoord;\nuniform sampler2D uTexture;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;const float STEPS = 16.0;\nconst float PI = 3.1415926;vec3 chromaticAbberation(vec2 st, float angle, float amount, float blend) {\nfloat aspectRatio = uResolution.x/uResolution.y;\nfloat rotation = angle * 360.0 * PI / 180.0;\nvec2 aberrated = amount * vec2(0.1 * sin(rotation) * aspectRatio, 0.1 * cos(rotation));\naberrated *= distance(st, vec2(0.5)) * 2.0;\nvec4 red = vec4(0);\nvec4 blue = vec4(0);\nvec4 green = vec4(0);\nfloat invSteps = 1.0 / STEPS;\nfloat invStepsHalf = invSteps * 0.5;\nfor(float i = 1.0; i <= STEPS; i++) {\nvec2 offset = aberrated * (i * invSteps);\nred += texture(uTexture, st - offset) * invSteps;\nblue += texture(uTexture, st + offset) * invSteps;\n}for (float i = 0.0; i <= STEPS; i++) {\nvec2 offset = aberrated * ((i * invSteps) - 0.5);\ngreen += texture(uTexture, st + offset) * invSteps;\n}\nreturn vec3(red.r, green.g, blue.b);\n}vec2 sphericalTransformation(\nfloat u,\nfloat v,\nfloat uCenter,\nfloat vCenter,\nfloat lensRadius,\nfloat tau) {\nfloat aspectRatio = uResolution.x/uResolution.y;\nu -= uCenter;\nv -= vCenter;float s = sqrt(u * u + v * v);\nif (s > lensRadius)\nreturn vec2(u + uCenter, v + vCenter);float z = sqrt(lensRadius * lensRadius - s * s);float uAlpha = (1.0 - (1.0 / tau)) * asin(u / lensRadius);\nfloat vAlpha = (1.0 - (1.0 / tau)) * asin(v / lensRadius);u = uCenter + z * sin(uAlpha);\nv = vCenter + z * sin(vAlpha);return vec2(u/aspectRatio, v);\n}float circularIn(float t) {\nreturn 1.0 - sqrt(1.0 - t * t);\n}vec2 fisheyeTransformation(\nfloat u,\nfloat v,\nfloat uCenter,\nfloat vCenter,\nfloat lensRadius,\nfloat distortionScale\n) {\nfloat aspectRatio = uResolution.x / uResolution.y;vec2 dir = vec2(u - uCenter, v - vCenter);dir.x /= lensRadius;\ndir.y /= lensRadius;float dist = length(dir) * 0.15;if (dist < 1.0) {\nfloat theta = atan(dir.y, dir.x);float r = dist * 2.0 * PI;\nfloat z = sqrt(1.0 - r * r) + 0.25;\nfloat rDist = atan(r, z) / PI;\nfloat newDist = mix(dist, rDist, 5.);dir.x = newDist * cos(theta);\ndir.y = newDist * sin(theta);\n}dir.x *= lensRadius;\ndir.y *= lensRadius;return mix(vec2(u/aspectRatio, v), vec2(uCenter/aspectRatio, vCenter) + dir, 1.0000);\n}vec2 discTransformation(\nfloat u,\nfloat v,\nfloat uCenter,\nfloat vCenter,\nfloat lensRadius,\nfloat distortionScale) {\nfloat aspectRatio = uResolution.x/uResolution.y;\nu -= uCenter;\nv -= vCenter;float s = sqrt(u * u + v * v);\nif (s > lensRadius)\nreturn vec2(u + uCenter, v + vCenter);\nfloat r = sqrt(u * u + v * v) / lensRadius;\nif(r == 0.0)\nreturn vec2(uCenter, vCenter);r = pow(r, distortionScale);\nfloat theta = atan(r);\nfloat rad = theta / r;u = rad * u + uCenter;\nv = rad * v + vCenter;return vec2(u/aspectRatio, v);\n}out vec4 fragColor;\nvoid main() {\nvec2 uv = vTextureCoord;\nvec4 color = texture(uTexture, uv);\nfloat aspectRatio = uResolution.x/uResolution.y;\nuv.x = uv.x * aspectRatio;\nvec2 sphereCoords = uv;\nvec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\npos.x *= aspectRatio;float radius = 0.5800 * uResolution.x/max(uResolution.x, uResolution.y);if(1 == 0) {\nsphereCoords = sphericalTransformation(\nmix(sphereCoords.x, 1.-sphereCoords.x, 0.0000),\nmix(sphereCoords.y, 1.-sphereCoords.y, 0.0000),\nmix(pos.x, 1.-pos.x, 0.0000),\nmix(pos.y, 1.-pos.y, 0.0000),\nradius/2.,\n1. + 1.0000 * 9.\n);\n} else if(1 == 1) {\nsphereCoords = discTransformation(\nmix(sphereCoords.x, 1.-sphereCoords.x, 0.0000),\nmix(sphereCoords.y, 1.-sphereCoords.y, 0.0000),\nmix(pos.x, 1.-pos.x, 0.0000),\nmix(pos.y, 1.-pos.y, 0.0000),\nradius/2.,\n1. + 1.0000 * 9.\n);\n} else if(1 == 2) {\nsphereCoords = fisheyeTransformation(\nmix(sphereCoords.x, 1.-sphereCoords.x, 0.0000),\nmix(sphereCoords.y, 1.-sphereCoords.y, 0.0000),\nmix(pos.x, 1.-pos.x, 0.0000),\nmix(pos.y, 1.-pos.y, 0.0000),\nradius/2.,\n1. + 1.0000 * 9.\n);\n}vec2 scaledCoords = (sphereCoords - 0.5) + 0.5;\nvec4 sphere = texture(uTexture, clamp(scaledCoords, 0.0, 1.0));\nfloat distFromPos = distance(uv, pos);\nfloat edgeSmooth = 0.001;\nfloat insideSphere = 1.0 - smoothstep(radius/2.0 - edgeSmooth, radius/2.0, distFromPos);\nfloat insideSphereAlpha = 1.0 - smoothstep(radius/2.0 + 0.002 - edgeSmooth, radius/2.0 + 0.002, distFromPos);\nsphere.rgb = chromaticAbberation(scaledCoords, atan(scaledCoords.y, scaledCoords.x), distFromPos * 0.8600, 1.0);\ncolor = mix(color, sphere, insideSphere);\ncolor.rgb += vec3((0.5000-0.5)*2.) * mix(0., circularIn(smoothstep(0., radius, distFromPos)), insideSphere);\nif(1 == 1) {\ncolor.a = insideSphereAlpha;\ncolor.rgb = mix(vec3(0), color.rgb, insideSphereAlpha);\n}\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect4"}],"options":{"name":"AI Orb","fps":60,"dpi":1.5,"scale":1,"includeLogo":false,"isProduction":false},"version":"1.5.2","id":"XyNQIXz7ip0Z6WSok07X"}